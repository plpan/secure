### 汇编知识

1. 伪指令
	- 汇编程序中以.开头的名称不是指令助记符，因此不会翻译成机器指令，他们被称之为伪指令，因为不是真正的指令
		- .section：将汇编代码划分成好几个段，程序被操作系统加载时，每个段会被加载到不同的地址，具备不同的r, w, x权限
			- .data：数据段，可读可写
				- 全局变量也保存在这个段内
			- .text：代码段，可读可执行
		- .globl：告诉汇编器，后面的这个符号要被链接器用到。

2. _start
	- _start是一个符号，代表一个地址，可以用在指令中。汇编程序经过汇编器处理之后，会把所有的符号替换成对应的地址值。
		- 变量会被替换为内存地址值
		- 函数会被替换为第一条指令的值
	_ _start函数和C程序中的main函数一样特殊，是整个汇编程序的入口。也即_start符号后的第一条指令就是整个程序的第一条指令

3. 汇编语法
	- Intel语法
		- Intel官方及Windows使用语法
		- mov ebx, eax   # 将eax的值赋给ebx [注意寄存器前没有%前缀，且寄存器位置相反]
	- AT&T语法
		- Unix使用语法
		- mov %eax, %ebx # 将eax的值赋给ebx
		- 我们这里使用的都是AT&T语法格式

3. [指令举例]数据转移指令
	- 通过具体的汇编指令来解释其含义
	- movl $1, %eax
		- l代表long，表示32位机器指令
		- 数据表示有具体的格式，以便和符号进行区分
			- 立即数用$前缀表示
			- 寄存器用%前缀表示3. 指令
	- 因此，这条指令的含义就是：将立即数1放置到32位寄存器eax中

4. [指令举例]中断指令
	- int $0x80
		- int：软中断指令，产生一个异常，CPU处理异常与中断类似，从用户模式切换到内核模式，并执行异常处理流程
		- 0x80：立即数，内核的异常处理程序根据这个立即数决定如何处理。而0x80代表了系统调用
			- 内核提供了很多系统服务给用户程序使用，但是用户不能直接去调用这些服务；而必须通过系统调用切换CPU的模式，用户可以提供几个参数，通过异常处理进入内核调用流程。当系统调用完成后，CPU在切换回用户模式，继续执行下一条指令，也即int之后的指令
		- eax, ebx为系统调用传递了两个参数:
			- eax代表系统调用号：1表示_exit系统调用
				- _exit表示终止当前进程
			- ebx的值传递给_exit调用调用作为参数

5. [指令举例]循环指令
	- 寄存器+cmp+jmp组合
		- 将循环次数保存在寄存器中，每次更改计数器的值，并比较计数器的值是否符合预期，最后用jmp控制语句的跳转
	- ecx+loop组合
		- ecx作为循环计数器，保存了循环的次数，并通过loop来控制语句跳转；其中loop就相当于 %ecx--; if(%ecx != 0) goto WHILE_STMT
